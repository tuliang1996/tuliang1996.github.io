静态内存：

* 自动申请，自动释放
* 大小固定，内存空间连续
* 从栈上分配的内存叫静态内存

动态内存：

* 程序员自己申请 new/malloc
* 大小取决于虚拟内存的大小，内存空间不连续
* java中自动回收，C中需要程序员使用free函数手动释放
* 从堆上分配的内存叫动态内存

（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多.

堆和栈的区别:

1.申请方式

栈:由系统自动分配，自动释放内存。例如,声明一个局部变量int b; 系统自动在栈中为b开辟空间.例如当在调用函数时，需要保存的变量，最明显的是在递归调用时，要系统自动分配一个栈的空间，后进先出的，而后又由系统释放这个空间.

堆:需要程序员自己申请，并指明大小，在c中用malloc函数

如char* p1 = (char*) malloc(10); //14byte

但是注意p1本身是在栈中的.

2 申请后系统的响应

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

3.申请大小的限制

栈：大小固定，内存空间连续。 在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（vc编译选项中可以设置,其实就是一个STACK参数,缺省2M），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

4.申请效率的比较

栈:程序员是无法控制栈内存。由系统自动分配，速度较快。

堆:程序员可以申请和释放堆内存。由malloc/new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.

5.堆和栈中的存储内容

栈:在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。

当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

6.内存的回收

栈：分配的内存，编译器会自动收回；

堆：分配的内存，要通过free()来显式地收回,否则会造成内存泄漏。

堆和栈的区别可以用如下的比喻来看出：

使用栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。

使用堆就像是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。
